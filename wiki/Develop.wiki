#labels Phase-Implementation,Featured
= C語言接口 =

{{{
/**
 * opencc_open:
 * @config_file: Location of configuration file.
 * @returns: A description pointer of the newly allocated instance of opencc.
 *
 * Make an instance of opencc.
 * 創建一個 opencc 實例。
 *
 * Note: Leave config_file to NULL if you do not want to load any configuration file.
 * 
 */
opencc_t opencc_open(const char * config_file);

/**
 * opencc_close:
 * @od: The description pointer.
 * @returns: 0 on success or non-zero number on failure.
 *
 * Destroy an instance of opencc.
 * 銷毁一個opencc實例。
 *
 */
int opencc_close(opencc_t od);

/**
 * opencc_convert:
 * @od: The opencc description pointer.
 * @inbuf: The pointer to the wide character string of the input buffer.
 * @inbufleft: The maximum number of characters in *inbuf to convert.
 * @outbuf: The pointer to the wide character string of the output buffer.
 * @outbufleft: The size of output buffer.
 *
 * @returns: The number of characters of the input buffer that converted.
 *
 * Convert string from *inbuf to *outbuf.
 * 轉換UCS-4編碼的文本。
 *
 * Note: Don't forget to assign **outbuf to L'\0' after called.
 *
 */
size_t opencc_convert(opencc_t od, ucs4_t ** inbuf, size_t * inbufleft,
		ucs4_t ** outbuf, size_t * outbufleft);

/**
 * opencc_convert_utf8:
 * @od: The opencc description pointer.
 * @inbuf: The UTF-8 encoded string.
 * @length: The maximum number of characters in inbuf to convert.
 *
 * @returns: The newly allocated UTF-8 string that converted from inbuf.
 *
 * Convert UTF-8 string from inbuf. This function returns a newly allocated
 * c-style string via malloc(), which stores the converted string.
 * DON'T FORGET TO CALL free() to recycle memory.
 * 轉換一個UTF-8編碼的文本，將會申請空間，需要手動釋放。
 * 
 */
char * opencc_convert_utf8(opencc_t t_opencc, const char * inbuf, size_t length);

/**
 * opencc_dict_load:
 * @od: The opencc description pointer.
 * @dict_filename: The name (or location) of the dictionary file.
 * @dict_type: The type of the dictionary.
 *
 * @returns: 0 on success or non-zero number on failure.
 *
 * Load a dictionary.
 *
 */
int opencc_dict_load(opencc_t t_opencc, const char * dict_filename,
		opencc_dictionary_type dict_type);

/**
 * 設置轉換模式。
*/
void opencc_set_conversion_mode(opencc_t t_opencc, opencc_conversion_mode conversion_mode);

/**
 * opencc_errno:
 *
 * @returns: The error number.
 *
 * Return an opencc_convert_errno_t which describes the last error that occured or
 * OPENCC_CONVERT_ERROR_VOID
 * 返回錯誤代碼。
 *
 */
opencc_error opencc_errno(void);

/**
 * opencc_perror:
 * @spec Prefix message.
 *
 * Print the error message to stderr.
 * 將錯誤信息輸出到stderr。
 *
 */
void opencc_perror(const char * spec);
}}}

== 使用UTF-8接口的實例 ==
{{{
void convert_to_trad(const char *simp)
{
    static opencc_t od = NULL;
    if (od == NULL) {
        od = opencc_open(OPENCC_DEFAULT_CONFIG_SIMP_TO_TRAD);
        if (od == (opencc_t) - 1) {
            opencc_perror("OpenCC initialization error");
            return;
        }
    }

    char * res = opencc_convert_utf8(od, simp, (size_t) - 1);
    if (res == (char *) - 1) {
        opencc_perror("OpenCC error");
        return NULL;
    }

    do_something(res);
    
    free(res);
}
}}}

== 使用UCS4接口的C++封裝 ==
{{{
// from ibus-pinyin
class opencc {
    static const int BUFFER_SIZE = 64;
public:
    opencc (void)
    {
        m_od = opencc_open (OPENCC_DEFAULT_CONFIG_SIMP_TO_TRAD);
        g_assert (m_od != NULL);
    }

    ~opencc (void)
    {
        opencc_close(m_od);
    }

    void convert (const gchar *in, String &out)
    {
        glong n_char;
        gunichar *in_ucs4 = g_utf8_to_ucs4_fast (in, -1, &n_char);

        ucs4_t *pinbuf = (ucs4_t *)in_ucs4;
        size_t inbuf_left = n_char;
        while (inbuf_left != 0) {
            ucs4_t *poutbuf = (ucs4_t *)m_buffer;
            size_t outbuf_left = BUFFER_SIZE;
            size_t retval = opencc_convert(m_od, &pinbuf, &inbuf_left, &poutbuf, &outbuf_left);
            if (retval == (size_t) -1) {
                /* append left chars in pinbuf */
                g_warning ("opencc_convert return failed");
                out << (gunichar *) pinbuf;
                break;
            }
            *poutbuf = L'\0';
            out << m_buffer;
        }
        g_free (in_ucs4);
    }
private:
    opencc_t m_od;
    gunichar m_buffer[BUFFER_SIZE + 1];
};
}}}